	/*fichier main*/

//biblio classique
#include <stdio.h>
#include <stdlib.h>

//biblio chaine
#include <string.h>

//couleurs windows
//#include <window.h>

//fichiers
#include <sys/types.h>
#include <dirent.h>



#include "header.h" //implémentation du fichier de prototypes

//#define BLANC = '\033[0;31m'
//#define


void main()
{
	char plateau[5][5][2] = {0}, sauv, linksave[256] = {"SIAM.save"};/*tableau avec toutes les positions des pions
				      j'ai choisie les position sous forme matriciel
				      donc plateau[y][x] le [2] est pour contenir
				      le type et l'orientation*/

	short int pionsE = 5, pionsR = 5, bascule = 0, victoire = 0, bascsave = 0; /* la bascule est pour savoir
		 c'est le tour de qui
	 les pions sont pour savoir
	 combien de pions on peut jouer*/


	//on place les montagnes aux positions initiales
	plateau[1][2][0] = 'M';
	plateau[2][2][0] = 'M';
	plateau[3][2][0] = 'M';

	regles();


  	do{
        	printf("Voulez-vous charger une partie précédente ? (O/N) : ");
        	saisie(plateau, bascule, linksave, &sauv);
      		majmin(&sauv);
    	}while(sauv != 'O' && sauv != 'N');

    if(sauv == 'O')
    {
	    chargement(plateau, &bascule, &pionsE, &pionsR, linksave);
    }
	while(!victoire)
	{

		entre(plateau, bascule, linksave, &pionsE, &pionsR, &bascsave);



		if(!bascule)
		{
			bascule = 1;
			continue;
		}
		else if(bascule)
		{
			bascule = 0;
			continue;
		}
	}
}



//fonctions

//fonction d'affichage du tableu, affiche toutes les pieces presente sur le tableau, est affiché à nouveau à chaque tours après l'effacement du tableau precédent pour le dynamisme


void affichage(char plateau[5][5][2])
{
	int x, y;
	char lettre = 'A';
	system("cls"); // vide la mémoire d'avant et c'est "clear" sous linus et cls sous windows

  //affichage du plateau
	printf("\n    1    2    3    4    5\n"); //abcsises du plateau
  //structure du plateau
	for(y = 0; y <= 4; y++)
	{
		printf("  --------------------------\n%c ", lettre++); //cadre +  repère en ordonnées
	//affichage des cases du plateau
		for(x = 0; x <= 4; x++)
		{
			printf("| ");
	//cas de la case vide
			if(plateau[y][x][0] == 0) //dans la 3eme dimention de notre tableau se trouve: le type de piece, l'oriantation
			{
				//teste pour l'affichage des +
				if((x == 0) || (x == 4) || (y == 0) || (y == 4))//condition pour etre sur un bors du plateau
				{
					printf("+  ");
				}
				else
				{
					printf("   ");
				}
			}
	//cas où il y aurrai une piece sur la case
			//teste pour affichage des pions
			if(plateau[y][x][0] == 'M')
			{
                //couleur de la montagne == marron
                Color(4,0);
				printf("M  ");
				Color(15,0);
			}
			if(plateau[y][x][0] == 'R' || plateau[y][x][0] == 'E')
			{
			printf("%c", plateau[y][x][0]);
        		Color(2,0);
        		printf("%c ", plateau[y][x][1]);	// [1] pour orientation des pièces
        		Color (15,0);
      }
		}
		//fermeture de la case
		printf("|\n");
	}
	printf("  --------------------------\n");//derniere ligne non comprit dans la boucle
}


// fonction de l'angle dans la poussé, appelle calculateur
short int angle(char plateau [5][5][2], short int bascule, char link [256], short int casx, short int casy, short int **pionR, short int **pionE)
{
	char orientation;
	short int res;
  do{

		printf("dans quel sens voulez vous pousser ?");
		if(casx == 0)
			printf("\nvers la droite (d)");
		if(casx == 4)
			printf("\nvers la gauche (g)");
		if(casy == 0)
			printf("\nvers le bas (b)\n:");
		if(casy == 4)
			printf("\nvers le haut (h)\n:");
  	saisie(plateau, bascule, link, &orientation);
	//test validité
	}while(orientation != 'd' && orientation != 'g' && orientation != 'b' && orientation != 'h');
  //cas coup possible
	if(calculateur(plateau, orientation, casx, casy) < 10)
	{
		printf("coup joué !");
    deplaceur(plateau, orientation, casx, casy, bascule, &pionR, &pionE);
		return 1;
	}
  //cas coups non valide
	printf("resisstance trop forte");
	getchar();
	return 0;
}



//voire si on peut simplifier
//fonction de calcule des resistances
short int calculateur(char plateau[5][5][2], char orientation, short int casx, short int casy)
{
  //* par 10 pour plus de lisbilité toute la res
	short int n, res = 0, sortie = 1;
    	printf("calculateur");
  //calcule selon l'orientation de la piece qui pousse
	if(orientation == 'd')
  	//ballayage de la ligne à droite
	       for(n = casx; n <= 4 && sortie; n++)
	       {
	       	       if(plateau[casy][n][1] == 'g')
			      			 res += 10;
       					if(plateau[casy][n][1] == 'd')
									res -= 10;
								if(plateau[casy][n][0] == 0)
								{
									sortie = 0;
									break;
								}
								if(plateau[casy][n][0] == 'M')
									res += 9;
					}

	if(orientation == 'g')
    //ballayage de la ligne à gauche
		for(n = casx; n >= 0 && sortie; n--)
		{
			if(plateau[casy][n][1] == 'd')
				res += 10;
			if(plateau[casy][n][1] == 'g')
				res -= 10;
			if(plateau[casy][n][0] == 0)
			{
				sortie = 0;
				break;
			}
			if(plateau[casy][n][0] == 'M')
				res += 9;
		}
	if(orientation == 'h')
    //ballayage de la colone au dessus
		for(n = casy; n >= 0 && sortie; n--)
		{
			if(plateau[n][casx][1] == 'b')
				res+=10;
			if(plateau[n][casx][1] == 'h')
				res-=10;
			if(plateau[n][casx][0] == 0)
			{
				sortie = 0;
				break;
			}
			if(plateau[n][casx][0] == 'M')
				res += 9;
		}
	if(orientation == 'b')
    //ballayage de la colone au dessous
		for(n = casy; n <= 4 && sortie; n++)
		{
			if(plateau[n][casx][1] == 'h')
				res+=10;
			if(plateau[n][casx][1] == 'b')
				res-=10;
			if(plateau[n][casx][0] == 0)
			{
				sortie = 0;
				break;
			}
			if(plateau[n][casx][0] == 'M')
				res +=9;
		}

	return res;//rend la resistance à l'appellant
}


// fonction d'affichage de couleurs
void Color(int couleurDuTexte,int couleurDeFond)
{
        HANDLE H = GetStdHandle(STD_OUTPUT_HANDLE);
        SetConsoleTextAttribute(H,couleurDeFond*16+couleurDuTexte);
}


//fonction de déplacement, coups possible si reserve du joueur<5
short int deplace(char plateau[5][5][2], short int bascule, char link[256], short int **pionR, short int **pionE)
{
	short int casx, casy, casxx, casyy;
	char orientation;

	//selection de la case où se trouve le pion	printf("piece à déplacer :\n");
	entrecase(plateau, bascule, link, &casx, &casy);	//test de la validité du coups
	if(((bascule == 1) && (plateau[casy][casx][0] != 'R')) || ((bascule == 0) && (plateau[casy][casx][0] != 'E'))) //blindage de la case
	{
		printf("case n'est pas de votre équipe (entré)");
		getchar();
		return 0;
	}

//selection de la case où l'on veut deplacer le pion	printf("lieu de déplacement :\n");
	entrecase(plateau, bascule, link, &casxx, &casyy);
	//test de la validité du coup
  //cas non valide
	if(!((((casxx-casx == 1)||(casx-casxx == 1)) && (casyy-casy == 0)) || (((casyy-casy == 1)||(casy-casyy == 1)) && (casxx-casx == 0))))
	{
		printf("\ncase non valide(entré)");
		getchar();
		return 0;
	}
  //cas valide
	if(plateau[casyy][casxx][0] != 0)
    	{
        	if(casxx-casx == 1)
			orientation = 'd';
		if(casx-casxx == 1)
			orientation = 'g';
		if(casyy-casy == 1)
			orientation = 'b';
		if(casy-casyy == 1)
			orientation = 'h';
		printf("--orient : %c", orientation);
    //cas ou cases de deplacement non vide
   	 //test de resistance
   		 //cas deplacement possible
		if((calculateur(plateau, orientation, casxx, casyy) < 10)&&(orientation == plateau[casy][casx][1]))
		{
			deplaceur(plateau, orientation, casx, casy, bascule,  &pionR, &pionE);
			return 1;//bien passé
		}
			//cas deplacement impossible
		printf("\nresisstance trop forte");
		getchar();
		return 0;
    }
  //mise a zero
    else
    {
        plateau[casyy][casxx][0] = plateau[casy][casx][0];
        plateau[casy][casx][0] = 0;
        plateau[casyy][casxx][1] = plateau[casy][casx][1];
        plateau[casy][casx][1] = 0;
    }
}


//fonction de déplacement des cases en travaux

void deplaceur(char plateau[5][5][2], char orientation, short int casx, short int casy, short int bascule, short int ***pionR, short int ***pionE)
{
  printf("--deplaceur");
	short int n, sortie = 1;
	char cache[2], cache2[2];
	cache[0] = plateau[casy][casx][0];	//cache contient la valeur de la case précedente
    	cache[1] = plateau[casy][casx][1];	//cache2 contient la valeur de la case actuelle en transformation!

	plateau[casy][casx][0] = 0;
	plateau[casy][casx][1] = 0;

	switch(orientation)
	{
		case 'd' :

		for(n = casx + 1; n <= 4 && sortie; n++)
	       	{	 //cas ou case non vide
           		if(plateau[casy][n][0] != 0)
		       	{
				if((plateau[casy][n][0] == 'E') && (n == 4))
				{
					(**pionE)++;
					plateau[casy][n][0] = cache[0];
                                        plateau[casy][n][1] = cache[1];
                                        return;
				}
				if((plateau[casy][n][0] == 'R') && (n == 4))
				{
					(**pionR)++;
					plateau[casy][n][0] = cache[0];
                                        plateau[casy][n][1] = cache[1];
                                        return;
				}
				if((plateau[casy][n][0] == 'M') && (n == 4))
					for(n = casx - 1; n >= 0; n--)
					{
						if(cache[0] == 'M')
							victoire('M');
						if(cache[0] == 'E')
							victoire('E');
						cache[0] == plateau[casy][n-1][0];
					}

        	    	 	cache2[0] = plateau[casy][n][0];
               			cache2[1] = plateau[casy][n][1];
		       		plateau[casy][n][0] = cache[0];
             			plateau[casy][n][1] = cache[1];
		       	}
	//cas case vide
       			if(plateau[casy][n][0] == 0)
			{
			 	plateau[casy][n][0] = cache[0];
				plateau[casy][n][1] = cache[1];
				sortie = 0;
				break;
			}

        		 printf("d");
       //changement de cache
			 cache[0] = cache2[0];
		   	 cache[1] = cache2[1];
		}
		 break;



	case 'g' :
    		for(n = casx - 1; n >= 0 && sortie; n--)
	       	{
		      //cas ou case non vide
           		if(plateau[casy][n][0] != 0)
	      		{
				if((plateau[casy][n][0] == 'E') &&  (n == 0))
                                {
                                        (**pionE)++;
					plateau[casy][n][0] = cache[0];
                                        plateau[casy][n][1] = cache[1];
                                        return;
                                }
                                if((plateau[casy][n][0] == 'R') && (n == 0))
                                {
                                        (**pionR)++;
					plateau[casy][n][0] = cache[0];
					plateau[casy][n][1] = cache[1];
					return;
                                }
                                if((plateau[casy][n][0] == 'M') && (n == 0))
                                        for(n = casx + 1; n <= 4 && sortie; n++)
					{
						if(cache[0] == 'M')
							victoire('M');
						if(cache[0] == 'E')
							victoire('E');
						cache[0] == plateau[casy][n+1][0];
					}




             			cache2[0] = plateau[casy][n][0];
                		cache2[1] = plateau[casy][n][1];
                		plateau[casy][n][0] = cache[0];
             			plateau[casy][n][1] = cache[1];
			}
      	//cas case vide
			if(plateau[casy][n][0] == 0)
			{
			 	plateau[casy][n][0] = cache[0];
				plateau[casy][n][1] = cache[1];
				sortie = 0;
				break;
			}
      //changement de cache
			cache[0] = cache2[0];
	      		cache[1] = cache2[1];
     		}
		break;

	case 'h':
    		for(n = casy - 1; n >= 0 && sortie; n--)
		{
				//cas case non vide
           		if(plateau[n][casx][0] != 0)
		       	{
				if((plateau[n][casx][0] == 'E') &&  (n == 0))
                                {
                                        (**pionE)++;
                                        plateau[n][casx][0] = cache[0];
                                        plateau[n][casx][1] = cache[1];
                                        return;
                                }
                                if((plateau[n][casx][0] == 'R') && (n == 0))
                                {
                                        (**pionR)++;
                                        plateau[n][casx][0] = cache[0];
                                        plateau[n][casx][1] = cache[1];
                                        return;
                                }
                                if((plateau[n][casx][0] == 'M') && (n == 0))
                                        for(n = casy + 1; n <= 4 && sortie; n++)
					{
						if(cache[0] == 'M')
							victoire('M');
						if(cache[0] == 'E')
							victoire('E');
						cache[0] == plateau[n+1][casx][0];
					}
             			cache2[0] = plateau[n][casx][0];
              			cache2[1] = plateau[n][casx][1];
		       		plateau[n][casx][0] = cache[0];
             			plateau[n][casx][1] = cache[1];
		       	}
      //cas case vide
		 	if(plateau[n][casx][0] == 0)
			{
				plateau[n][casx][0] = cache[0];
				plateau[n][casx][1] = cache[1];
				sortie = 0;
				break;
			}
  //changement de cache
			cache[0] = cache2[0];
	      		cache[1] = cache2[1];
     		}
		break;

	case 'b' :

        	for(n = casy + 1; n <= 4 && sortie; n++)
 		{		//cas ou case non vide
        	    	if(plateau[n][casx][0] != 0)
        	    	{
				if((plateau[n][casx][0] == 'E') &&  (n == 4))
                                {
                                        (**pionE)++;
                                        plateau[n][casx][0] = cache[0];
                                        plateau[n][casx][1] = cache[1];
                                        return;
                                }
                                if((plateau[n][casx][0] == 'R') && (n == 4))
                                {
                                        (**pionR)++;
                                        plateau[n][casx][0] = cache[0];
                                        plateau[n][casx][1] = cache[1];
                                        return;
                                }
                                if((plateau[n][casx][0] == 'M') && (n = 4))
                                        for(n = casy - 1; n >= 0 && sortie; n--)
					{
						if(cache[0] == 'M')
							victoire('M');
						if(cache[0] == 'E')
							victoire('E');
						cache[0] == plateau[n-1][casx][0];

					}


        	     		cache2[0] = plateau[n][casx][0];
        	        	cache2[1] = plateau[n][casx][1];
        	        	plateau[n][casx][0] = cache[0];
        	     		plateau[n][casx][1] = cache[1];
        	    	}
        //cas case vide
            	if(plateau[n][casx][0] == 0)
                {
            		    	plateau[n][casx][0] = cache[0];
           	 	    	plateau[n][casx][1] = cache[1];
           		     	sortie = 0;
               	 		break;
           		}
  //changement de cache
        		cache[0] = cache2[0];
      			cache[1] = cache2[1];
     		}
		break;
	}
	return;

}

//fonction d'entrée de choix de coups, appelle affichage, deplace, place, rotation, sauvegarde, saisie
short int entre(char plateau [5][5][2], short int bascule,char link[256], short int* pionsE, short int* pionsR, short int *bascsave)
{
	char choix;
	short int coup = 0, **pion, victoire = 0;

	do
	{
		affichage(plateau); 	//affichage a chaque tour
	//utilisation de la bascule pour determiner à quel des joueurs c'est le tour
		if(bascule)	//bascule = 1 -> rhino
		{   Color(10, 0);
			printf("\n\nc'est aux RHINO de jouer");
			Color(15, 0);
			pion = &pionsR;
		}

		else if(!bascule)		//bascule = 0 -> elephan
		{
		    Color(10, 0);
			printf("\n\nc'est aux ELEPH de jouer"); // on saute de deux lignes pour la visibilité des différentes instructions
			Color(15, 0);
			pion = &pionsE;
		}
		//affichage des pions en reserve
		Color(11, 0);
		printf("\nil vous reste %d pions en dehors\n", **pion);
		Color(15, 0);
		//proposition de coups en fonction de la reserve de pions
		if(**pion != 5)
			printf("\nrotation(r)\ndéplacer(d)"); // une rotation compte pour un tour et correspond au changement d'orientation
		if(**pion != 0)
	        	printf("\nposer un pion(p)\n");
    		//proposition de la sauvegarde, disponible à tout moment
        	if(*bascsave == 0)
			printf("\nparametriser la sauvegarde(s)\n\n");
		if(*bascsave == 1)
			printf("\n		sauvegarder (s)\n\n");


		printf(": ");
    		saisie(plateau, bascule, link, &choix); //choix de mvt à blinder


		// appel des fonction selon choix, blindé
		if(choix == 'r' && !((*pionsR == 5 && bascule == 1) || (*pionsE == 5 && bascule == 0)))		//si coup == 0 -> erreur donc reprend du début
      			coup = rotation(plateau, bascule, link);

		if(choix == 'd' && !((*pionsR == 5 && bascule == 1) || (*pionsE == 5 && bascule == 0)))
			coup = deplace(plateau, bascule, link,&pionsR, &pionsE);

		if(choix == 'p' && ((bascule == 1 && *pionsR > 0)||(bascule == 0 && *pionsE > 0)))
			coup = place(plateau, bascule, link, &pion, &pionsR, &pionsE);


		//differentes saves
		if(choix == 's' && *bascsave == 1)
    		{
        		sauvegarde(plateau, bascule, link);
       			printf("\npartie sauvegardée sur : %s", link);
    		}
    		else if(choix == 's' && *bascsave == 0)
    		{
      			para_save(plateau, bascule, link);
      			(*bascsave) = 1;
    		}

	}while(!coup);

	return victoire;
}



//fonction de choix de case
void entrecase(char plateau[5][5][2], short int bascule, char link[256], short int *casx, short int *casy)
{
	char casyprime;
	short int casxprime;

  	do{
        	printf("quel est l'abssices de votre case ? :");
        	scanf("%d", &casxprime);
		getchar();
          	if(casxprime == 27)
          	{
            		quitter(plateau, bascule, link);
          	}
        }while(!(casxprime <= 5 && casxprime > 0));
		(*casx) = --casxprime;

  	do{
        	printf("quel est l'ordonné de votre case ? :");
        	saisie(plateau, bascule, link, &casyprime);
  		majmin(&casyprime);
  	}while(!(casyprime <! 'A' || casyprime >! 'E'));

	*casy = casyprime - 65;
}

//donne la version majuscule de la chose
void majmin (char *c)
{
  if(*c > 97 && *c < 122)
    (*c) -= 32;
}



//fonction qui modifie l'orientation d'une piece
void orien_rotation(char plateau[5][5][2],short int bascule, char link[256], short int casx, short int casy)
{
	char rot;
	//boucle dont la sortie demande la saisie d'une orientation 'valable'
	while (rot != 'd' && rot != 'g' && rot!= 'h' && rot!= 'b')
	{
		printf("\nquelle orientation voulez vous lui donner ?\nbas(b)\nhaut(h)\ngauche(g)\ndroite(d)\n:");
        	saisie(plateau, bascule, link, &rot);              //demande l'orientation à blinder
	}
	//afectation de la nouvelle orientation
        plateau[casy][casx][1] = rot;   //changement de rotation du pion
}



//fonction de placement des pieces, apelle enrtecase, orien_rotation, angle, calculateur
short int place(char plateau[5][5][2], short int bascule, char link[256], short int ***pion, short int **pionR, short int **pionE)
{
	short int casx, casy;
	char orientation, rot;

	entrecase(plateau, bascule, link, &casx, &casy);
	//test si case valide
	if(casx == 4 || casx == 0 || casy == 4 || casy == 0)
	{
		printf("--case valide");
  //cas case vide
		if(plateau[casy][casx][0] == 0)
		{
			printf("--cas case vide");
			if(bascule == 0)
				plateau[casy][casx][0] = 'E';
			if(bascule == 1)
				plateau[casy][casx][0] = 'R';

			orien_rotation(plateau, bascule, link, casx, casy);
			(***pion)--;	//on retire 1 pion du deck

			return 1;	//on return 1 car bien passé
		}
	//cas case non vide
		else if(plateau[casy][casx][0] != 0)
        	{
			printf("--cas cas non vide");
    //cas angle
                	if((casx == 0 || casx == 4) && (casy == 0 || casy == 4))
               		{
                        angle(plateau, bascule, link, casx, casy, pionR, pionE);
                        	(***pion)--;
                       		return 1;//bien passé
               		 }

			//cas ou c'est sur les lignes et colones
			if(casx == 0)
      				orientation = 'd';
			if(casx == 4)
				orientation = 'g';
			if(casy == 0)
				orientation = 'b';
			if(casy == 4)
				orientation = 'h';
			printf("\norientation du mvt : %c", orientation);

      //choix de l'orientaion de la piece
      //boucle dont seul un choix  'valable' permet la sortie
			while (rot != 'd' && rot != 'g' && rot!= 'h' && rot!= 'b')
		        {
                		printf("\nquelle orientation voulez vous lui donner ?\nbas(b)\nhaut(h)\ngauche(g)\ndroite(d)\n:");
				saisie(plateau, bascule, link, &rot); //saisie de l'orientation
       	 		}

	//cas d'une case non vide
      //test des resistance
			if ((calculateur(plateau, orientation, casx, casy) < 10)&&(rot == orientation))
        //cas valide
			{
				printf("res > 10");
      		//déplacement de la piece
		    		deplaceur(plateau, orientation,casx, casy, bascule, &pionR, &pionE);
              			if(bascule)
			                plateau[casy][casx][0] = 'R';
        			else if(!bascule)
               				 plateau[casy][casx][0] = 'E';
    				plateau[casy][casx][1] = rot;

				(***pion)--;

				return 1;//bien passé
               		}
    		//cas no valide
                   	printf("\nentrée non valide");
          		getchar();

              		return 0;
		}

	}
	//cas case non valide
	//test de validité, doit etre sur un bord
	else if(!(casx == 4 || casx == 0 || casy == 4 || casy == 0))
	{
		printf("\ncase non valide");
		getchar();

		return 0;
	}
}


//quitte le programme en douceur
void quitter(char plateau[5][5][2], short int bascule, char link[256])
{
	char save;

	do{
  		printf("voulez-vous sauvegarder?   oui(1)   non(2) : ");
  		scanf("%c",&save);
		getchar();
	}while(save != '1' && save != '2');

 	if (save == '1')
  	{
     		sauvegarde(plateau, bascule, link);
  	}

  	printf("fermeture du programme, vous retrouverez ce que vous avez entrée\n\n");
	getchar();
	system("clear");
  	exit(0);
}


//fonction d'affichage des regels en debut de partie
void regles()
{

// message d'ouverture
    	system("cls");
    	//couleur du texte
    	Color(12, 0);
    	printf("\n\n\n                  		VOUS ETES SUR SIAM  \n\n\n\n         LE JEU TELLEMENT BIEN QUE MEME MACRON A LE TEMPS D'Y JOUER");
    	Color(15, 0);
    	getchar();
//afichage des règles
	system("cls");
	//couleur du texte
	Color(6, 0);
	printf("Au debut de la partie, chaque joueur choisit son equipe :\n -les elephants\n -les rhinoceros.\nLe jeu commence avec les trois montagnes placees au centre du plateau (3B ;3C ;3D).\nLes pions de chacun des joueurs en dehors du plateau. \n\nDans le siam, les elephants blancs sont les premiers a jouer. \n\nA chaque tour le joueur ne peut effectuer qu’une seule et unique action.\n\nLes different coup ou action possibles : \n- Poser un pion sur le plateau. \n- Deplacer un pion sur le plateau. \n- Effectuer une rotation d’un pion sur le plateau. \n\nLes conditions pour poser un pion:\n- Le joueur doit avoir au moins un pion a l’exterieur du plateau.\n- Le pion ne peut etre poser que sur les cases exterieures du plateau (ligne A ou E, ou colonne 1 ou 5).\n- La case doit etre vide ou repondre aux exigences de la pousse afin de deplacer le pion qui l’occupe pour pouvoir y poser un pion.\n\nLes conditions de deplacement:\n- Les pions peuvent se deplacer sur les 4 cases qui leurs sont adjacentes.\n- Si la case est libre le deplacement est possible.\n- Si la case est occupee, le pion deplacer vas tenter une poussee.\n\nLa rotation permet de modifier l’orientation du pion, 4 orientations sont possibles : haut, bas, droite, gauche.\n");
  	Color(10, 0);
  	printf("\n\n----Quitter a tout moment grace a ESC+ENTER-----\n");
  	Color(15, 0);
  	getchar();
}

//fonction de rotation, appelle entrecase, orien_rotation
short int rotation(char plateau [5][5][2], short int bascule, char link[256])
{
	short int casx, casy;
	//choix de la case
	entrecase(plateau, bascule, link, &casx, &casy);

	if(((plateau[casy][casx][0] != 'R') && (bascule == 1)) || ((plateau[casy][casx][0] != 'E') && (bascule == 0)))
	{
		printf("\nentrée non valide");
		return 0;
	}

	orien_rotation(plateau, bascule, link, casx, casy);

	return 1;
}

//fonction de saisie des choix proposé
void saisie(char plateau[5][5][2], short int bascule, char link[256], char *ptchoix)
{
    char entre = 0;
    short int c;
    do
    {
        scanf("%c", &entre);
	getchar();

    	//saisie d'échap pour quitter
        if (entre == 27)
        {
         	quitter(plateau, bascule, link);
        }
    		//saisie d'un choix
        if(entre > 65 && entre < 90)
    		entre += 32;
    }
    while(entre==0);

    /*				//videur de buffer
	while (c != EOF && c != '\n')
		c = getchar();
*/
    //choix retourné à l'appellant
    *ptchoix = entre;
  	return;
}

//fn de sauvegarde et quitte en menus

//fonction d'ouverture d'un jeux sauvegardé
void chargement(char plateau[5][5][2], short int *bascule, short int *pionsE, short int *pionsR, char link [256])
{
  	short int erreur, n = 0, choix;
	struct dirent *lecture;
  	DIR* dossier = NULL;
  	dossier = opendir(".");


  	system("cls");
  	Color(2,0);
  	printf("	----PARAMETRE DE CHARGEMENT----\n\n\n");

  	if(dossier != NULL)
  	{
    		do
    		{
			n = 0;
			printf("\n\n");
			Color(11,0);
    			while((lecture = readdir(dossier)))
    			{
    	    			if(strstr(lecture->d_name, ".save"))
				{
					printf("-------------------------------------------------\n");
					printf(" %d -- %s\n", n + 1, lecture->d_name);
					n++;
				}

    			}
			printf("-------------------------------------------------");
    			rewinddir(dossier);
    			Color(2,0);
    			printf("\nlequel ? : ");
    			Color(15,0);
    			scanf("%d", &choix);
    		}while(!(choix <= 100 && choix > 0));

		//passe devant tous les autres fichier
		for(n = 0;(lecture = readdir(dossier)) && n < 100;)
    		{
    	    		if(strstr(lecture->d_name, ".save"))
			{
				if( n == choix-1)
				{
					link = lecture->d_name;
					break;
				}
				n++;
			}
    		}
            Color(2,0);
    		printf("Vous chargerez le fichier : %s\n", link);
		getchar();
    		closedir(dossier);
  	}


	//fonction de chargement
	printf("chargement");
    	char cache;
    	short int code, m, t;

 	FILE* save = NULL;
    	save = fopen(link, "r"); // ouverture du fichier en mode lecture
    	fseek(save, 0, SEEK_SET);

  //cas de sauvegarde lisible
    if(save != NULL)
    {	//balayage du plateau pour placement des information sauvegardé
        for(n = 0; n <= 4; n++)
            for(m = 0; m <= 4; m++)
            {
              for(t = 0; t <= 1; t++)
                {
                        fscanf(save, "%c", &cache);
                        if(cache == 'O')
                        	plateau[n][m][t] = 0;
                        else
                        	plateau[n][m][t] = cache;
                }
             	if(plateau[n][m][0] == 'R')
                  	(*pionsR)--;
             	if(plateau[n][m][0] == 'E')
                  	(*pionsE)--;
            }

      	fscanf(save, "%d", &cache);
      	if(cache == 'R')
        	(*bascule) = 0;
      	else if (cache == 'E')
        	(*bascule) = 1;
      	//fermeture de save
        fclose(save);
        Color(15,0);
    }
  	//cas fichier non lisible ou non existant
    	else
    	{
    	    Color(12,0);
        	printf("\nerreur d'ouverture de fichier");

        	getchar();
        	return;
    	}
}


//fonction de sauvegarde de l'etat de la partie
void sauvegarde(char plateau[5][5][2], short int bascule, char link[256])
{
    short int code, m, n, t;
    FILE* save = NULL;

    save = fopen(link, "w");
    fseek(save, 0, SEEK_SET);
    Color(2,0);
    printf("partie sauvegardée sur %s", link);

    if(save != NULL)
    {
        //écrire le plateau
        for(n = 0; n <= 4; n++)
            for(m = 0; m <= 4; m++)
              	for(t = 0; t<2; t++)
                {
                    if(plateau[n][m][t] == 0)
                        putc('O', save);
                    else
                        putc(plateau[n][m][t], save);
                }
      if(bascule == 1)
      	putc('R', save);
      else if (bascule == 0)
        putc('E', save);

      	//fermer le fichier
        fclose(save);
        Color(15,0);
      return;
    }
  //cas erreur
    else
    {
        Color(12,0);
        printf("erreur d'ouverture de fichier");
        getchar();
        return;
    }
}


//fonction de victoire, depend du joueur dont c'est le tour au moment de la victoire
void victoire(char basculeprime)
{	//affichage du message de victoire
  	//partie modulable
	switch(basculeprime)
	{
		case 'R':
			victoire_R();
			break;
		case 'E':
			victoire_E();
			break;
		default:
			return;
	}
  	//partie comune
	printf("vous avez gagné\n");
	getchar();
  //sortie du programme comme fin de la partie
	perror("fin du programme");
	exit(0);
}



//fonction d'annimation pour la victoire
void victoire_R ()
{
    while (1)
    {
        Color(11,0);
        system("cls");
        printf("\n\n\n\n\n\n\n\n\n\n\n");
        Color(12,0);
        printf("\n\n\n\n\n\n");
        printf("                                     VICTOIRE");
        Color(2,0);
        printf("\n\n\n\n\n");
        printf("=============================== Les RHINO ont gagne ===============================\n");
        Sleep(200);

        Color(11,0);
        system("cls");
        printf("\n\n\n\n\n\n\n\n\n\n\n");
        Color(12,0);
        printf("\n\n\n\n\n\n");
        Color(2,0);
        printf("\n\n\n\n\n");
        printf("=============================== Les RHINO ont gagne ===============================\n");
        Sleep(200);
    }

}


void victoire_E ()
{
    while(1)
    {
         Color(11,0);
        system("cls");
        printf("\n\n\n\n\n\n\n\n\n\n\n");
        Color(12,0);
        printf("\n\n\n\n\n\n");
        printf("                                     VICTOIRE");
        Color(2,0);
        printf("\n\n\n\n\n");
        printf("=============================== Les ELEPH ont gagne ===============================\n");
        Sleep(200);

        Color(11,0);
        system("cls");
        printf("\n\n\n\n\n\n\n\n\n\n\n");
        Color(12,0);
        printf("\n\n\n\n\n\n");
        Color(2,0);
        printf("\n\n\n\n\n");
        printf("=============================== Les ELEPH ont gagne ===============================\n");
        Sleep(200);
    }

}
